import random
import langchain_openai
import langchain_core
def generate_questions() -> list[str]:
    questions = ['What tool is the speaker discussing in the video?', 'Which debugger is the speaker primarily focusing on in the video?', 'What is a breakpoint and where does the speaker suggest placing it in the code?', 'What is the alternative to using manual breakpoints in older versions of Python?', 'What is the built-in alternative to manual breakpoints introduced in Python 3.7?', 'What command can the speaker use to get a list of all the various commands available in pdb?', 'How can the speaker continue running your code in pdb?', 'What command can the speaker use to quit pdb and continue running the rest of your code?', 'What command can the speaker use to see the lines of code around where pdb is about to execute?', 'How can the speaker jump back up to a previous point in the code listing in pdb?', 'What command can the speaker use to get a bigger chunk of code listing in pdb?', 'What command can the speaker use to see a stack trace of the function calls that led to the current execution point in pdb?', 'How can the speaker navigate up and down the stack frames in pdb?', 'How do the speaker navigate up and down stack frames in a debugger?', 'What is a useful feature of a debugger that can replace print statements?', 'How can the speaker print variables in a debugger?', 'What are the commands for incrementally watching the execution of code in a debugger?', 'What is a common command to finish a function and go back to where it was called from in a debugger?', 'How can the speaker prevent accidentally committing code that contains debugger modifications?']
    return random.sample(questions, min(len(questions), 5))


def generate_answers(question: str, answer: str, _: str) -> bool | str:
    reference_answers = dict(zip(['What tool is the speaker discussing in the video?', 'Which debugger is the speaker primarily focusing on in the video?', 'What is a breakpoint and where does the speaker suggest placing it in the code?', 'What is the alternative to using manual breakpoints in older versions of Python?', 'What is the built-in alternative to manual breakpoints introduced in Python 3.7?', 'What command can the speaker use to get a list of all the various commands available in pdb?', 'How can the speaker continue running your code in pdb?', 'What command can the speaker use to quit pdb and continue running the rest of your code?', 'What command can the speaker use to see the lines of code around where pdb is about to execute?', 'How can the speaker jump back up to a previous point in the code listing in pdb?', 'What command can the speaker use to get a bigger chunk of code listing in pdb?', 'What command can the speaker use to see a stack trace of the function calls that led to the current execution point in pdb?', 'How can the speaker navigate up and down the stack frames in pdb?', 'How do the speaker navigate up and down stack frames in a debugger?', 'What is a useful feature of a debugger that can replace print statements?', 'How can the speaker print variables in a debugger?', 'What are the commands for incrementally watching the execution of code in a debugger?', 'What is a common command to finish a function and go back to where it was called from in a debugger?', 'How can the speaker prevent accidentally committing code that contains debugger modifications?'], ['The debugger in Python.', 'The pdb debugger that ships with Python.', 'A breakpoint is where the program will stop to allow debugging. The speaker suggests placing it right before a problem occurs in the code.', 'In older versions of Python, the alternative to manual breakpoints is using the `import pdb` and `pdb.settrace()` statements.', 'The built-in alternative to manual breakpoints introduced in Python 3.7 is the `breakpoint()` function.', 'help', "You can continue running your code by using the 'c' command, which is short for 'continue'.", "You can quit pdb and continue running the rest of your code by using the 'q' or 'quit' command.", "You can use the 'list' or 'l' command to see the lines of code around where pdb is about to execute.", "You can jump back up to a previous point in the code listing by typing 'list .' in pdb.", "You can use the 'll' command to get a bigger chunk of code listing in pdb.", "You can use the 'where' command to see a stack trace of the function calls that led to the current execution point in pdb.", "You can navigate up and down the stack frames in pdb by using the 'up' and 'down' commands.", "You can navigate up and down stack frames in a debugger by using the 'up' and 'down' commands. Going up two frames will move the speaker to a different frame, and going down will take the speaker back to the previous frame. If the speaker are already at the last frame, it will indicate that the speaker are at the newest frame. Going up to the top will show the speaker the oldest frame.", 'A useful feature of a debugger that can replace print statements is the ability to print variables and expressions directly in the debugger. This allows the speaker to inspect the values of variables and expressions during debugging.', "You can print variables in a debugger by typing the variable name or expression on the command line. If the variable name collides with debugger commands, the speaker can use 'p' to print the variable. Additionally, the speaker can pretty print variables using 'pp' for a more readable output.", "The commands for incrementally watching the execution of code in a debugger are 'next' (n) and 'step' (s). 'Next' jumps to the next line of code, allowing the speaker to see the execution flow. 'Step' jumps into a function call, enabling the speaker to step through the function's execution.", "The command is 'r', which is short for 'return'.", 'You can use a tool that plugs directly into pre-commit, such as the debug statements hook, which prevents commits that contain imports of debugger modules or breakpoint calls.']))
    chat = langchain_openai.ChatOpenAI(model="gpt-3.5-turbo-1106", temperature=0)
    chat_answer = chat.invoke(
        [
            langchain_core.messages.SystemMessage(content="You will be given question, reference answer pair and users answer. "
                                  'You have to decide if the answer is correct. '
                                  'If it is respond with a single work "Correct" otherwise return a hint about the answer. '),
            langchain_core.messages.SystemMessage(content='The question: ' + question + '\n'
                                  'The reference answer: ' + reference_answers[question]),
            langchain_core.messages.HumanMessage(
                content=answer
            )
        ]
    ).content
    if chat_answer.startswith("Correct"):
        return True
    return chat_answer
